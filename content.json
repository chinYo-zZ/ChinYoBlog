{"posts":[{"title":"C++ 反射","text":"c++构建反射系统的学习记录 一、类对象反射当前框架 首先进行工厂的搭建：ClassFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#pragma once#include &lt;string&gt;#include &lt;map&gt;using namespace std;#include &quot;utility/Singleton.h&quot;using namespace yazi::utility;namespace yazi {namespace reflect { //注册反射类需继承的基类 class Object { public: Object() {}; virtual ~Object() {}; }; //为函数指针取别名 typedef Object* (*create_object)(void); //工厂 class ClassFactory { //友元类，让单例类工厂可以访问私有变量 friend class Singleton&lt;ClassFactory&gt;; public: void register_class(const string&amp; className, create_object method); Object* create_class(const string&amp; className); private: //储存注册反射的类 map&lt;string, create_object&gt; m_classMap; };}}// ClassFactory.cpp ------------------------------------------------------------#include &quot;ClassFactory.h&quot;using namespace yazi::reflect;void ClassFactory::register_class(const string&amp; className, create_object method){ m_classMap[className] = method;}Object* ClassFactory::create_class(const string&amp; className){ // tip : C ++ map find()函数用于查找具有给定键值k 的元素。 // 如果找到该元素，则返回指向该元素的迭代器。否则，它返回一个指向map末尾的迭代器，即map :: end()。 auto it = m_classMap.find(className); if (it == m_classMap.end()) { return nullptr; } return it-&gt;second();} 将注册操作封装进类和宏中 12345678910111213141516171819202122//ClassRegister.h#pragma once#include &quot;reflect/ClassFactory.h&quot;namespace yazi {namespace reflect { class ClassRegister { public: ClassRegister(const string&amp; className, create_object method) { Singleton&lt;ClassFactory&gt;::instance()-&gt;register_class(className, method); } };#define REGISTER_CLASS(className) \\Object * createObject##className(){ \\ Object* obj = new className(); \\ return obj; \\ } \\ClassRegister classRegister##className(#className,createObject##className)}} 单例模式类模版 12345678910111213141516171819202122232425//Singleton.h#pragma oncenamespace yazi {namespace utility { template&lt;typename T&gt; class Singleton { public: static T* instance() { if (m_instance == NULL) m_instance = new T(); return m_instance; } private: Singleton() {} Singleton(const Singleton&lt;T&gt;&amp;); Singleton&lt;T&gt;&amp; operator = (const Singleton&lt;T&gt;&amp;); ~Singleton() {}; private: static T* m_instance; }; template&lt;typename T&gt; T* Singleton&lt;T&gt;::m_instance = NULL;}} 测试类 123456789101112131415161718192021#pragma once#include &lt;iostream&gt;#include &quot;reflect/ClassRegister.h&quot;using namespace std;using namespace yazi::reflect;class A : public Object{public: A(){} ~A(){} void show() { cout &lt;&lt; &quot;A：C++！启动！&quot; &lt;&lt; endl; }public: string m_name;};// tip：注意宏的命名空间REGISTER_CLASS(A); 测试 1234567891011121314//main函数#include &lt;iostream&gt;using namespace std;#include &quot;reflect/ClassFactory.h&quot;using namespace yazi::reflect;#include &quot;test/A.h&quot;int main(){ ClassFactory* factory = Singleton&lt;ClassFactory&gt;::instance(); A* a = (A*)factory-&gt;create_class(&quot;A&quot;); a-&gt;show();} ## 二、类成员数据反射","link":"/ChinYoBlog/2024/04/24/C-Reflect/"},{"title":"UE5自定义资源（二）","text":"UE版本：5.2.1 ue4不适用 自定义资源图标123456789101112131415161718192021void FHtnAssetEditorModule::StartupModule(){ /* 其他操作 ------------*/ //创建Slate样式集 _styleSet = MakeShareable(new FSlateStyleSet(TEXT(&quot;HtnStyle&quot;))); //获取插件管理器，目的是获取Icon路径 TSharedPtr&lt;IPlugin&gt;plugin = IPluginManager::Get().FindPlugin(&quot;DemoModule&quot;); FString contentDir = plugin-&gt;GetContentDir(); //设置获取到路径为根路径 _styleSet-&gt;SetContentRoot(contentDir); // FSlateImageBrush结构体封装一些图片信息 FSlateImageBrush* thumbnailBrush = new FSlateImageBrush(_styleSet-&gt;RootToContentDir(TEXT(&quot;HtnUI02&quot;), TEXT(&quot;.png&quot;)), FVector2D(128.0, 128.0)); FSlateImageBrush* iconBrush = new FSlateImageBrush(_styleSet-&gt;RootToContentDir(TEXT(&quot;HtnUI02&quot;), TEXT(&quot;.png&quot;)), FVector2D(128.0, 128.0)); //将样式设置到自定义资源 _styleSet-&gt;Set(&quot;ClassThumbnail.HierarchicalTaskNetwork&quot;, thumbnailBrush); _styleSet-&gt;Set(&quot;classIcon.HierarchicalTaskNetwork&quot;, iconBrush); //注册样式 FSlateStyleRegistry::RegisterSlateStyle(*_styleSet);} ClassThumbnail.[youAssetAame]和classIcon[youAssetAame]youAssetAame不要带前缀U 新建节点 创建新的GraphSchema继承自UEdGraphSchema，再创建节点行为继承自FEdGraphSchemaAction 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// .hUCLASS()class UHtnGraphSchema :public UEdGraphSchema{ GENERATED_BODY()public: virtual void GetGraphContextActions(FGraphContextMenuBuilder&amp; contextMenuBuilder) const override;};USTRUCT()struct FNewNodeAction :public FEdGraphSchemaAction{ GENERATED_BODY()public: FNewNodeAction(){} FNewNodeAction(FText inNodeCategory, FText inMenuDesc, FText inToolTip, const int32 inGrouping) :FEdGraphSchemaAction(inNodeCategory, inMenuDesc, inToolTip, inGrouping){} virtual UEdGraphNode* PerformAction(UEdGraph* parentGraph, UEdGraphPin* fromPin, const FVector2D location, bool bSelectNewNode);};//.cppvoid UHtnGraphSchema::GetGraphContextActions(FGraphContextMenuBuilder&amp; contextMenuBuilder) const{ TSharedPtr&lt;FNewNodeAction&gt; newNodeAction( new FNewNodeAction(FText::FromString(TEXT(&quot;Nodes&quot;)), FText::FromString(TEXT(&quot;New Node&quot;)), FText::FromString(TEXT(&quot;Makes a new node&quot;)),0)); contextMenuBuilder.AddAction(newNodeAction);}UEdGraphNode* FNewNodeAction::PerformAction(UEdGraph* parentGraph, UEdGraphPin* fromPin, const FVector2D location, bool bSelectNewNode){ //必须使用自己节点，后文会提到 UHtnEdGraphNode* result = NewObject&lt;UHtnEdGraphNode&gt;(parentGraph); result-&gt;NodePosX = location.X; result-&gt;NodePosY = location.Y; result-&gt;CreatePin(EEdGraphPinDirection::EGPD_Input, TEXT(&quot;Inputs&quot;), TEXT(&quot;SomeInput&quot;)); result-&gt;CreatePin(EEdGraphPinDirection::EGPD_Output, TEXT(&quot;Outputs&quot;), TEXT(&quot;Output1&quot;)); result-&gt;CreatePin(EEdGraphPinDirection::EGPD_Output, TEXT(&quot;Outputs&quot;), TEXT(&quot;Output2&quot;)); parentGraph-&gt;Modify(); parentGraph-&gt;AddNode(result, true, true); return result;} 做完节点行为需要将自己的Schema替换原本的Schema 123456//在初始化界面的函数中_workingGraph = FBlueprintEditorUtils::CreateNewGraph( _workingAsset, NAME_None, UEdGraph::StaticClass(), UHtnGraphSchema::StaticClass() // 用自己的UHtnGraphSchema，ue5一般都是用反射进行注册，UHtnGraphSchema要有UCLASS宏); 注册完成后即可通过UHtnGraphSchema::GetGraphContextActions呼出节点选择框 节点行为 创建自己的节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//.hUCLASS()class HTNASSETEDITOR_API UHtnEdGraphNode : public UEdGraphNode{ GENERATED_BODY()public: virtual FText GetNodeTitle(ENodeTitleType::Type titalType)const override{return FText::FromString(&quot;TestNodeTitle&quot;); } virtual FLinearColor GetNodeTitleColor() const override { return FLinearColor(FColor::Green); } virtual bool CanUserDeleteNode()const override{ return true; } virtual void GetNodeContextMenuActions(class UToolMenu* menu, class UGraphNodeContextMenuContext* context) const override;};//.cppvoid UHtnEdGraphNode::GetNodeContextMenuActions(UToolMenu* menu, UGraphNodeContextMenuContext* context) const{ FToolMenuSection&amp; section = menu-&gt;AddSection(TEXT(&quot;SectionName&quot;), FText::FromString(TEXT(&quot;Custom Node Actions&quot;))); UHtnEdGraphNode* node = (UHtnEdGraphNode*)this; //右键行为 section.AddMenuEntry(TEXT(&quot;AddPinEntry&quot;), FText::FromString(TEXT(&quot;Add Pin&quot;)), FText::FromString(TEXT(&quot;Creates a new pin&quot;)), FSlateIcon(TEXT(&quot;HtnStyle&quot;), TEXT(&quot;HtnAssetEditor.NodeAddPinIcon&quot;)), FUIAction(FExecuteAction::CreateLambda ( [node]() { node-&gt;CreatePin(EEdGraphPinDirection::EGPD_Output, TEXT(&quot;Outputs&quot;), TEXT(&quot;Another Output&quot;)); node-&gt;GetGraph()-&gt;NotifyGraphChanged(); node-&gt;GetGraph()-&gt;Modify(); } )) ); section.AddMenuEntry(TEXT(&quot;DeletePinEntry&quot;), FText::FromString(TEXT(&quot;Delete Pin&quot;)), FText::FromString(TEXT(&quot;Delete the last pin&quot;)), FSlateIcon(TEXT(&quot;HtnStyle&quot;), TEXT(&quot;HtnAssetEditor.NodeDeletePinIcon&quot;)), FUIAction(FExecuteAction::CreateLambda ( [node]() { UEdGraphPin* pin = node-&gt;GetPinAt(node-&gt;Pins.Num() - 1); if (pin-&gt;Direction != EEdGraphPinDirection::EGPD_Input) { node-&gt;RemovePin(pin); node-&gt;GetGraph()-&gt;NotifyGraphChanged(); node-&gt;GetGraph()-&gt;Modify(); } } )) ); section.AddMenuEntry(TEXT(&quot;DeleteEntry&quot;), FText::FromString(TEXT(&quot;Delete Node&quot;)), FText::FromString(TEXT(&quot;Delete the node&quot;)), FSlateIcon(TEXT(&quot;HtnStyle&quot;), TEXT(&quot;HtnAssetEditor.NodeDeleteNodeIcon&quot;)), FUIAction(FExecuteAction::CreateLambda ( [node]() { node-&gt;GetGraph()-&gt;RemoveNode(node); } )) );}","link":"/ChinYoBlog/2024/06/16/Custom2/"},{"title":"UE5 GAS PlayMontageAndWait源码解析","text":"PlayMontageAndWait源码解析 声明的四个委托分别对应四个异步Exec 1234567891011121314//声明动态多播委托DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMontageWaitSimpleDelegate);UPROPERTY(BlueprintAssignable)FMontageWaitSimpleDelegate OnCompleted;UPROPERTY(BlueprintAssignable)FMontageWaitSimpleDelegate OnBlendOut;UPROPERTY(BlueprintAssignable)FMontageWaitSimpleDelegate OnInterrupted;UPROPERTY(BlueprintAssignable)FMontageWaitSimpleDelegate OnCancelled; 蓝图函数界面根据此函数创建 1234UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (DisplayName=&quot;PlayMontageAndWait&quot;, HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))static UAbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(UGameplayAbility* OwningAbility, FName TaskInstanceName, UAnimMontage* MontageToPlay, float Rate = 1.f, FName StartSection = NAME_None, bool bStopWhenAbilityEnds = true, float AnimRootMotionTranslationScale = 1.f, float StartTimeSeconds = 0.f); 通过这个静态函数创建UAbilityTask_PlayMontageAndWait对象，并根据蓝图写入的数据赋值给成员变量 1234567UAbilityTask_PlayMontageAndWait* MyObj = NewAbilityTask&lt;UAbilityTask_PlayMontageAndWait&gt;(OwningAbility, TaskInstanceName);MyObj-&gt;MontageToPlay = MontageToPlay;MyObj-&gt;Rate = Rate;MyObj-&gt;StartSection = StartSection;MyObj-&gt;AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;MyObj-&gt;bStopWhenAbilityEnds = bStopWhenAbilityEnds;MyObj-&gt;StartTimeSeconds = StartTimeSeconds; 绑定一些函数，通过动画实例绑定montage和委托，动画播放时触发委托，委托通知绑定的函数，在绑定的函数里再广播给蓝图准备的四个Exec 123456789//UAbilityTask_PlayMontageAndWait::Activate()InterruptedHandle = Ability-&gt;OnGameplayAbilityCancelled.AddUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageInterrupted);BlendingOutDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageBlendingOut);AnimInstance-&gt;Montage_SetBlendingOutDelegate(BlendingOutDelegate, MontageToPlay);MontageEndedDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageEnded);AnimInstance-&gt;Montage_SetEndDelegate(MontageEndedDelegate, MontageToPlay); 外部取消播放蒙太奇 123456789void UAbilityTask_PlayMontageAndWait::ExternalCancel(){ if (ShouldBroadcastAbilityTaskDelegates()) { // 蓝图委托 OnCancelled.Broadcast(); } Super::ExternalCancel();} 再绑定前会先调用播放蒙太奇函数 1234if (ASC-&gt;PlayMontage(Ability, Ability-&gt;GetCurrentActivationInfo(), MontageToPlay, Rate, StartSection, StartTimeSeconds) &gt; 0.f){ //...} asynctask没找到具体逻辑在哪 剩下的一些逻辑挺好理解的","link":"/ChinYoBlog/2024/06/01/GASmon/"},{"title":"UE5 NewObject ： Outer参数","text":"在创建对象的过程中，使用NewObejct等一系列创建对象的函数的时候，会看到Outer参数，在官方文档中，参数的意思为： 看到这样的描述其实是很难意会的 深入源码,直到看到new 123456789101112if (!bSubObject){ FMemory::Memzero((void *)Obj, TotalSize); new ((void *)Obj) UObjectBase( const_cast&lt;UClass*&gt;(InClass), InFlags|RF_NeedInitialization, InternalSetFlags, InOuter, InName, OldIndex, OldSerialNumber);} 在UObjectBase中，outer赋值给OuterPrivate 12/** Object this object resides in. */UObject* OuterPrivate; 根据注释可知，Outer可以理解为新创建对象的持有者，类似于角色身上持有组件，Outer为角色，会控制所创建对象的生命周期； 经过一些测试，Outer与对象的垃圾回收有关。即使通过 TSharedPtr 或 UPROPERTY 对 UObject 有很强的引用，如果Outer销毁，创建的所有对象也会消失。","link":"/ChinYoBlog/2024/06/08/UE5NewObjectOuter/"},{"title":"UE 从C++写蓝图函数的一些有用的操作","text":"UPARAM(ref) 使用此宏可以在不将引用标记为const的情况下使其在蓝图中变成输入 不加const或者UPARAM(ref)的情况下蓝图会将引用变为输出 AutoCreateRefTerm 使用此说明符，蓝图会自动创建引用（在蓝图中const &amp; 没有输入的情况下会报错），不需要手动创建 未完待续。。。","link":"/ChinYoBlog/2024/08/12/UEBlueFromC/"},{"title":"UE 垃圾回收的执行时机","text":"需要测试的有以下类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class NonUObejct{public: NonUObejct(); virtual ~NonUObejct();};UCLASS()class UTestObject : public UObject { GENERATED_BODY()public: UTestObject(); virtual ~UTestObject();};USTRUCT()struct FTestStruct{ GENERATED_BODY()public: UPROPERTY() UTestObject* TestClass = nullptr;};UINTERFACE()class UTestInterface : public UInterface { GENERATED_BODY()};class ITestInterface{ GENERATED_BODY()public: virtual void TestMethod() = 0;};UCLASS()class UObjectWithInterface : public UObject , public ITestInterface{ GENERATED_BODY()public: UObjectWithInterface(); virtual ~UObjectWithInterface(); virtual void TestMethod() override;}; 对应CPP 12345678910111213141516171819202122232425262728293031323334NonUObejct::NonUObejct(){ UE_LOG(LogTemp, Warning, TEXT(&quot;NonUobject created&quot;));}NonUObejct::~NonUObejct(){ UE_LOG(LogTemp, Warning, TEXT(&quot;NonUobject destroyed&quot;));}UTestObject::UTestObject(){ UE_LOG(LogTemp, Warning, TEXT(&quot;UTestObject created&quot;));}UTestObject::~UTestObject(){ UE_LOG(LogTemp, Warning, TEXT(&quot;UTestObject destroyed&quot;));}UObjectWithInterface::UObjectWithInterface(){ UE_LOG(LogTemp, Warning, TEXT(&quot;UObjectWithInterface created&quot;));}UObjectWithInterface::~UObjectWithInterface(){ UE_LOG(LogTemp, Warning, TEXT(&quot;UObjectWithInterface destroyed&quot;));}void UObjectWithInterface::TestMethod(){ UE_LOG(LogTemp, Warning, TEXT(&quot;Interface : TestMethod()&quot;));} gc.CollectGarbageEveryFrame 1 命令可以每帧执行垃圾回收 一、UPROPERTY()标记在玩家控制器中 12345678910111213141516171819UCLASS()class TESTGC_API ATestPlayerController : public APlayerController{ GENERATED_BODY()public: ATestPlayerController(); virtual ~ATestPlayerController(); virtual void BeginPlay()override;private: UPROPERTY() UTestObject* _TestObject = nullptr;};//cppvoid ATestPlayerController::BeginPlay(){ Super::BeginPlay(); //没有给参数Outer！ _TestObject = NewObject&lt;UTestObject&gt;();} 开始运行 1LogTemp: Warning: UTestObject created 结束运行 1LogTemp: Warning: UTestObject destroyed 玩家控制器消失，可以销毁_TestObject，关系为玩家控制器持有_TestObject 创建后马上设置为空 1234567void ATestPlayerController::BeginPlay(){ Super::BeginPlay(); //没有给参数Outer！ _TestObject = NewObject&lt;UTestObject&gt;(); _TestObject = nullptr;} 123LogTemp: Warning: UTestObject created...LogTemp: Warning: UTestObject destroyed 此时没有类引用_TestObject，垃圾回收销毁_TestObject 二、Outer引用12345678910void ATestPlayerController::BeginPlay(){ Super::BeginPlay(); //this给参数Outer,相当于持有者为玩家控制器 _TestObject = NewObject&lt;UTestObject&gt;(this); UTestGameInstance* gameInstance = GetGameInstance&lt;UTestGameInstance&gt;(); gameInstance-&gt;Object = _TestObject; UGameplayStatics::OpenLevel(gameInstance, TEXT(&quot;otherMap&quot;));} 切换关卡后 1LogTemp: Warning: UTestObject destroyed 为什么有游戏实例的引用，还是被销毁了，原因是Outer参数将玩家控制器设置为持有者，玩家控制器被销毁，连带持有的对象也被销毁了如果去掉this，切换关卡后将不会销毁，因为被游戏实例引用，并且没有父级 三、未继承Object123456private: UPROPERTY() UTestObject* _TestObject = nullptr; UPROPERTY() NonUObejct* Non = nullptr;}; 直接报错，不继承Object只能使用智能指针管理内存 四、数组GC123456789101112private: UPROPERTY() TArray&lt;UTestObject*&gt; TArray;};void ATestPlayerController::BeginPlay(){ TArray.Add(NewObject&lt;UTestObject&gt;()); TArray.Add(NewObject&lt;UTestObject&gt;()); TArray.Add(NewObject&lt;UTestObject&gt;());} 运行停止后，三次销毁 1234567void ATestPlayerController::BeginPlay(){ TArray.Add(NewObject&lt;UTestObject&gt;()); TArray.Add(NewObject&lt;UTestObject&gt;()); TArray.Add(NewObject&lt;UTestObject&gt;()); TArray.Empty();} 依旧是三次销毁，说明数组也会GC 五、结构体1234567891011private: UPROPERTY() FTestStruct _TStruct;};void ATestPlayerController::BeginPlay(){ _TStruct.TestClass = NewObject&lt;UTestObject&gt;(); _TStruct.TestClass = nullptr;} 创建后马上销毁 六、接口使用接口指针储存类对象必须使用TScriptInterface&lt;&gt;模版才能实现GC，否则会报错，数组同理 123456789private: UPROPERTY() TScriptInterface&lt;ITestInterface&gt; _Inter = nullptr;};void ATestPlayerController::BeginPlay(){ _Inter = NewObject&lt;UObjectWithInterface&gt;();}","link":"/ChinYoBlog/2024/05/27/UEGC/"},{"title":"UE5 GameplayTag图鉴","text":"GameplayTag GameplayTag RequestGameplayTag（静态） 123static FGameplayTag RequestGameplayTag(const FName&amp; TagName, bool ErrorIfNotFound=true); 从已有的tag集合中获取指定的tag IsValidGameplayTagString（静态） 1234static bool IsValidGameplayTagString(const FString&amp; TagString, FText* OutError = nullptr, FString* OutFixedString = nullptr); 判断输入的tag是否有效，如果无效则注册tag 匹配函数 MatchesTag 12bool MatchesTag(const FGameplayTag&amp; TagToCheck) const; 是否匹配父标记 MatchesTagExact 12bool MatchesTagExact(const FGameplayTag&amp; TagToCheck) const 判断是否完全匹配，可以直接使用双等号，重载了运算符，效果是一样的 蓝图中使用bool变量选择 MatchesTagDepth 12int32 MatchesTagDepth(const FGameplayTag&amp; TagToCheck) const; 根据标签匹配数量返回整数","link":"/ChinYoBlog/2024/07/28/UEGameplayTag/"},{"title":"UE 添加碰撞预设（collision presets）","text":"给项目添加碰撞预设 碰撞通道可以在引擎中添加 碰撞预设好像只能在ini文件中添加 1234567891011+Profiles=(Name=&quot;Projectile&quot;,CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName=&quot;Projectile&quot;,CustomResponses=((Channel=&quot;Pawn&quot;,Response=ECR_Overlap),(Channel=&quot;Visibility&quot;,Response=ECR_Ignore),(Channel=&quot;Camera&quot;,Response=ECR_Ignore),(Channel=&quot;Ability&quot;,Response=ECR_Ignore),(Channel=&quot;Projectile&quot;,Response=ECR_Ignore),(Channel=&quot;AbilityOverlapProjectile&quot;,Response=ECR_Overlap),(Channel=&quot;Pickup&quot;,Response=ECR_Ignore)),HelpMessage=&quot;Overlaps Pawns and AbilityOverlapProjectile&quot;) 可以根据参数名称去搜索枚举 比如CollisionEnabled，如下","link":"/ChinYoBlog/2024/08/01/UEcollisionpresets/"},{"title":"UE5的一些报错","text":"动态多播委托不触发AddDynamic绑定的方法得被UFUNCTION标记，否则绑定无效 动态代理对象类型可以使用UPROPERTY标记，并设置为BlueprintAssignable，从而暴露给蓝图使用，其他代理均无法使用（不加编译可过，调用出错） Unable to find ‘class’, ‘delegate’, ‘enum’, or ‘struct’ with name ‘XXX’ 由Unreal Header Tool (UHT)发出 原因是函数中有数据结构没有被宏标记 删除或使用其他委托","link":"/ChinYoBlog/2024/03/05/UEcpperror/"},{"title":"UE5 GAS PossessedBy()和OnRep_PlayerState()","text":"在默认Pawn类中对角色进行多人游戏GAS组件初始化记录 123456789101112131415161718void AALSCharacter::PossessedBy(AController* NewController){ Super::PossessedBy(NewController); AChPlayerState* PS = GetPlayerState&lt;AChPlayerState&gt;(); UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;PossessedBy ------- %s --&gt; %s&quot;), *PS-&gt;GetName(), *NewController-&gt;GetName()), true, false, FLinearColor::Red, 100.f); UKismetSystemLibrary::DrawDebugSphere(GetWorld(), this-&gt;GetActorLocation(), 100.f, 12, FLinearColor::Red, 100.f); }void AALSCharacter::OnRep_PlayerState(){ Super::OnRep_PlayerState(); UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT(&quot;OnRep_PlayerState-------%s&quot;), *GetPlayerState()-&gt;GetName()), true, false, FLinearColor::Red, 100.f); UKismetSystemLibrary::DrawDebugSphere(GetWorld(), this-&gt;GetActorLocation(), 100.f, 12, FLinearColor::White, 100.f);} PossessedBy()和OnRep_PlayerState()各执行了两次，PossessedBy()在服务端上执行，OnRep_PlayerState()在客户端上执行 其中OnRep_PlayerState()是因为Pawn中PlayerState变化触发的 第一次修改 第二次修改 然后调用客户端OnRep_PlayerState()进行客户端代理Pawn的修改，执行两次，两个Pawn","link":"/ChinYoBlog/2024/07/15/UEmultiplayer/"},{"title":"UE5 使用Fromat创建格式化的UELog","text":"123456789101112131415161718192021222324#define MY_LOG(Format, ...) MyLog(TEXT(Format), __VA_ARGS__)inline void FillArgs(FStringFormatOrderedArguments&amp; Args){ //终止递归}template&lt;typename F, typename... R&gt;void FillArgs(FStringFormatOrderedArguments&amp; Args, F&amp;&amp; First, R&amp;&amp;... Rest){ Args.Add(Forward&lt;F&gt;(First)); FillArgs(Args, Forward&lt;R&gt;(Rest)...);}template&lt;typename... T&gt;void MyLog(const TCHAR* Format, T&amp;&amp;... Args){ FStringFormatOrderedArguments OrderedArgs; FillArgs(OrderedArgs, Forward&lt;T&gt;(Args)...); FString Message = FString::Format(Format, MoveTemp(OrderedArgs)); GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Cyan, Message); UE_LOG(LogTemp, Display, TEXT(&quot;%s&quot;), *Message);} 后续更新支持类-&gt;GetName()","link":"/ChinYoBlog/2024/06/28/UEfromat/"},{"title":"UE 优化方面的内容","text":"瓶颈定位 Game Thread 首先会对整个游戏世界进行逻辑层面的计算与模拟(e.g.Spawn 多少个新的 actor、每个 actor 在这一帧位于何处、角色移动、动画状态等等)，所有这些信息会被输送到 Draw Thread Draw Thread(也叫 Rendering Thread) 会根据这些信息，剔除(Culling)掉不需要显示的部分(e.g. 处于屏幕外的物体)，接着创建一个列表，其中包含了渲染每个物体必备的关键信息(e.g. 如何被着色、映射哪些纹理等等)，再将这个列表输送给 GPU Thread GPU Thread 在获取了这个列表之后，会计算出每个像素最终需要如何被渲染在屏幕上，形成这一帧的画面综上，对于每一帧来说，这三者的执行顺序依次为：Game Thread → Draw Thread → GPU Thread 一帧的总耗时，取决于三者中开销最严重、即耗时最长的线程 CPU 优化 替换tick 时间线组件 循环计时器 远距离时禁用tick或者tick间隔延长 事件驱动 编码 对象池 复杂运算用c++ 多线程进行数据计算（不要引用对象）（TaskGraph） 分帧 一帧要做的事，分给多个帧完成 蓝图和cpp C++：遍历大量数据执行复杂计算 蓝图：上层业务逻辑 C++ 如果返回类型带有const，&amp; 可以用auto防止临时对象构造 循环中复用临时变量 在构造函数中使用初始化列表 利用好constexpr编译期计算 碰撞优化 尽可能使用简单碰撞 不交互的装饰物关闭碰撞 UI优化 合图 ： 一个界面会用到多个资源来进行拼接。那么客户端在绘制这个页面时，会自动检索这个界面引用到的n个资源，需要计算n次。而如果恰好这n个资源都在一个合图里，则程序只需要读取一次合图文件即可完成这个页面的绘制，只需要计算1次。 有许多控件的默认状态就是visible，例如image，因此在确认控件不接收交互事件时可以设为set hit test invisible可以减少不必要的开销。 Invalidation Box和Retainer Box：避免每帧渲染","link":"/ChinYoBlog/2024/07/01/UEoptimize/"},{"title":"C++ 标准库提供了可以用来填充或生成容器的内容","text":"当然可以！下面是对 &lt;algorithm&gt; 头文件中填充相关函数的详细解释，包括它们的功能和用法： 1. std::fill功能：用指定的值填充范围中的所有元素。 原型： 12template&lt; class ForwardIt, class T &gt;void fill( ForwardIt first, ForwardIt last, const T&amp; value ); 示例： 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() { std::vector&lt;int&gt; v(10); std::fill(v.begin(), v.end(), 42); // 填充所有元素为 42 for (int num : v) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} 2. std::generate功能：用指定的生成器函数填充范围中的元素。生成器函数需要返回一个值，该值会被填充到容器中。 原型： 12template&lt; class ForwardIt, class Generator &gt;void generate( ForwardIt first, ForwardIt last, Generator gen ); 示例： 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() { std::vector&lt;int&gt; v(10); int start = 1; std::generate(v.begin(), v.end(), [start]() mutable { return start++; }); for (int num : v) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} 3. std::iota功能：用递增的值填充范围中的元素。起始值是指定的，从这个值开始递增。 原型： 12template&lt; class ForwardIt, class T &gt;void iota( ForwardIt first, ForwardIt last, T value ); 示例： 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt; // For std::iotaint main() { std::vector&lt;int&gt; v(10); std::iota(v.begin(), v.end(), 1); // 从 1 开始递增填充 for (int num : v) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} 4. std::fill_n功能：用指定的值填充指定数量的元素。这是 std::fill 的一种变体，适用于填充固定数量的元素。 原型： 12template&lt; class OutputIt, class Size, class T &gt;OutputIt fill_n( OutputIt first, Size count, const T&amp; value ); 示例： 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() { std::vector&lt;int&gt; v(10); std::fill_n(v.begin(), 5, 99); // 填充前 5 个元素为 99 for (int num : v) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} 这些函数提供了多种方式来填充容器中的元素，可以根据你的需求选择合适的函数。 5. 自定义函数如果需要一个更灵活的生成序列的方法，可以编写自定义函数来填充容器。以下是一个示例，展示了如何使用自定义函数实现类似于 std::iota 的行为。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;template&lt;typename ForwardIterator, typename T&gt;void custom_iota(ForwardIterator first, ForwardIterator last, T value) { while (first != last) { *first++ = value++; }}int main() { std::vector&lt;int&gt; v(10); custom_iota(v.begin(), v.end(), 1); // 从 1 开始填充 for (int num : v) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} 6. std::partial_sumstd::partial_sum 计算范围内元素的部分和。如果使用递增的生成器填充源范围，可以得到类似 std::iota 的结果。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt; // For std::partial_sumint main() { std::vector&lt;int&gt; v(10); std::iota(v.begin(), v.end(), 1); // 用 1, 2, 3, ..., 10 填充 v std::vector&lt;int&gt; result(v.size()); std::partial_sum(v.begin(), v.end(), result.begin()); for (int num : result) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} std::partial_sum 的结果是部分和，所以这不完全等同于 std::iota，但展示了如何通过标准库的算法来生成类似的结果。 这些方法提供了不同的方式来填充或生成序列，能够在需要类似 std::iota 功能时作为替代方案。","link":"/ChinYoBlog/2024/08/23/algo1/"},{"title":"C++ 算法： 区间符合的二分查找","text":"属于个人总结 二分查找 区间符合的二分查找 二分查找模版12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int BinarySearch(vector&lt;int&gt; &amp;nums, int Target){ int i = 0, j = nums.size() - 1; while (i &lt;= j) { int mid = i + (j - i) / 2; if (nums[mid] &lt; Target) { i = mid + 1; } else if (nums[mid] &gt; Target) { j = mid - 1; } else { return mid; } } return -1;}int main(){ vector&lt;int&gt; vec{5, 10, 15, 20, 25, 30, 35, 40, 45, 50}; cout &lt;&lt; BinarySearch(vec, 30); return 0;} 区间符合的二分查找所有极端情况都可以保证low指向最终结果 可以看这些题目 寻找重复数 P2678 [NOIP2015 提高组] 跳石头","link":"/ChinYoBlog/2024/08/07/algorithmtemplate/"},{"title":"C++ 拷贝(深浅)构造函数和移动构造函数，还有完美转发（^_^）","text":"目录 代码示例 std::move 完美转发 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma warning(disable:4996)class MyString {private: char* buffer; // 用于存储字符串的动态内存指针public: // 默认构造函数 MyString() : buffer(nullptr) {} //// 拷贝构造函数(浅) //MyString(const MyString&amp; other) { // if (other.buffer) { // buffer = other.buffer; // } // else { // buffer = nullptr; // } //} // 拷贝构造函数(深) MyString(const MyString&amp; other) { if (other.buffer) { //新创建指针 buffer = new char[std::strlen(other.buffer) + 1]; std::strcpy(buffer, other.buffer); } else { buffer = nullptr; } } // 移动构造函数 MyString(MyString&amp;&amp; other) noexcept : buffer(nullptr) { if (other.buffer) { buffer = other.buffer; // 直接转移指针所有权 other.buffer = nullptr; // 将原对象置为空指针，避免重复释放 } } // 析构函数 ~MyString() { if (buffer) { std::cout &lt;&lt; &quot;调用析构函数&quot;&lt;&lt;std::endl; delete[] buffer; } } // 打印字符串内容 void print() const { if (buffer) { std::cout &lt;&lt; buffer; } else { std::cout &lt;&lt; &quot;(null)&quot;; } std::cout &lt;&lt; std::endl; } // 设置字符串内容 void set(const char* value) { if (buffer) { delete[] buffer; } buffer = new char[std::strlen(value) + 1]; std::strcpy(buffer, value); }};int main(){ MyString str1; str1.set(&quot;Hello&quot;); MyString str2 = str1; // 调用拷贝构造函数 std::cout &lt;&lt; &quot;str1: &quot;; str1.print(); // 输出 &quot;Hello&quot; std::cout &lt;&lt; &quot;str2: &quot;; str2.print(); // 输出 &quot;Hello&quot; MyString str3 = std::move(str1); // 调用移动构造函数 std::cout &lt;&lt; &quot;str1 移动后: &quot;; str1.print(); // 输出 &quot;(null)&quot;，因为资源已经移动给了 str3 std::cout &lt;&lt; &quot;str3: &quot;; str3.print(); // 输出 &quot;Hello&quot;} std::move在 C++ 中，std::move 是一个函数模板，它用来显式地将其参数转换为右值引用。它的定义通常如下所示： 1234template &lt;typename T&gt;typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) noexcept { return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);} 这意味着当你调用 std::move(x) 时，如果 x 是一个左值（如一个具名变量），它将被转换为一个右值引用。这个过程并不会实际搬移任何数据，而是通过编译器的类型转换机制告知编译器将 x 视为可以安全移动的对象。 内存的影响当你使用 std::move 对左值进行操作时，内存本身并不会发生变化。std::move 只是改变了对象的类型标记，告诉编译器此对象可以被移动而非复制。具体来说： 对象标记为可移动：调用 std::move(x) 后，x 的类型被转换为一个右值引用，例如 T&amp;&amp;，其中 T 是 x 的原始类型。这意味着编译器可以将 x 的资源（如指针或资源所有权）移动到另一个对象，而不需要执行深拷贝操作。 没有内存数据的搬移：std::move 本身并不会导致任何内存的移动或拷贝。它仅仅是一个类型转换的语法工具，告知编译器如何处理这个对象。 搬移语义的应用：当你使用 std::move 返回值或传递给接受右值引用参数的函数时，这些函数可以利用搬移语义来实现高效的资源管理，比如移动构造函数和移动赋值运算符。 完美转发12345678910111213141516171819202122232425#include &lt;utility&gt;using namespace std;// 另一个函数接受转发的参数void some_function(int&amp; arg) { cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; endl;}void some_function(int&amp;&amp; arg) { cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; endl;}// 模板函数实现完美转发template &lt;typename T, typename U&gt;void forwarder(U&amp;&amp; arg) { // 将参数 arg 完美转发给其它函数 some_function(arg); // 因为函数形参就是左值，所以默认都是执行左值引用的函数 some_function(forward&lt;U&gt;(arg)); // 进行完美转发后，就可以将arg继续按传进来的值类型继续传值}int main() { int x = 5; forwarder&lt;int&gt;(x); // x 是左值，转发为 int&amp; forwarder&lt;int&gt;(10); // 10 是右值，转发为 int&amp;&amp; return 0;}","link":"/ChinYoBlog/2024/07/07/cppcopymove/"},{"title":"游戏开发中经常用到的设计模式","text":"游戏开发中经常用到的设计模式 单例模式 模板模式 状态模式 原型模式 组件模式 观察者模式 发布-订阅模式 单例模式通常用于游戏中的全局管理类，保证整个程序（进程）中只有一个实例对象存在。有很多种常见的写法： 作为全局变量（饿汗模式） 1Game game; 效果：在程序启动时就会创建 game 对象，之后可以直接使用。 作为函数内部的 static 变量（懒汗模式） 123456Game &amp;getGame() { static Game game; return game;}getGame().updatePlayers(); 效果：第一次调用 getGame() 时会初始化，之后的调用会直接返回上次创建的实例。 根据你的需要，如果你需要在程序一启动时 game 对象就可用，就用饿汗模式。 如果 game 的初始化需要某些条件，例如创建 Game 类前需要 OpenGL 初始化，那么可用懒汗模式： 12345int main() { glfwInit(); // 初始化 OpenGL getGame().initialize(); // 第一次调用 getGame 会初始化 game 单例 getGame().updatePlayers(); // 之后的调用总是返回对同一个 game 单例的引用} 提示：如果要把单例对象的定义放在头文件中，务必添加 inline 修饰符，而不是 static，否则会导致多个 cpp 文件各自有一个 Game 对象。 12345678// Game.hppinline Game game;inline Game &amp;getGame() { static Game game; return game;} 封装在类内部由于所有单例全部暴露在全局名字空间，容易产生混乱。一般会把单例对象或函数封装在类内部，并且把 Game 的构造函数设为 private，避免用户不慎直接创建出本应只有单个实例的 Game 类。 作为全局变量（饿汗模式） 12345678910111213struct Game { ... Game(Game &amp;&amp;) = delete;private: Game() { ... }public: inline static Game instance; // 如果定义在头文件中，需要 inline！};Game::instance.updatePlayers(); 作为函数内部的 static 变量（懒汗模式） 12345678910111213141516struct Game { ... Game(Game &amp;&amp;) = delete;private: Game() { ... }public: inline static Game &amp;instance() { // 这里的 inline 可以省略，因为类体内就地实现的函数自带 inline 效果 static Game game; return game; }};Game::instance().updatePlayers(); 通用的单例模式模板12345678910template &lt;class T&gt;inline T &amp;singleton() { // 这里的 inline 可以省略，因为就地实现的模板函数自带 inline 效果 // 只有第一次进入时会构造一遍 T，之后不会再构造 // 不同的 T 会实例化出不同的 singleton 实例，各自体内的 static 变量独立计算，互不干扰 static T inst; return inst;}singleton&lt;Game&gt;().updatePlayers();singleton&lt;Other&gt;().someMethod(); 任何类型 T，只要以 singleton&lt;T&gt;() 形式获取，都能保证每个 T 都只有一份对象。（前提是你不要再 T() 创建对象） 模板模式 注意：模板模式和 C++ 的模板并没有必然关系！模板模式只是一种思想，可以用模板实现，也可以用虚函数实现（大多反而是用虚函数实现的） 模板模式用于封装游戏中一些相似的处理逻辑，把共同的部分集中到一个基类，把不同的细节部分留给子类实现。 和策略模式很像，只不过这里接收策略的直接就是基类自己。 例如，一个角色固定每一帧需要移动 3 次，然后绘制 1 次。显然需要把“移动”和“绘制”作为两个虚函数接口，让子类来实现。 123456789101112131415161718192021222324struct Character { virtual void draw() = 0; virtual void move() = 0;};struct Player : Character { void draw() override { drawPlayer(); } void move() override { movePlayer(); }};struct Enemy : Character { void draw() override { drawEnemy(); } void move() override { moveEnemy(); }}; 如果让负责调用 Character 的人来实现每一帧需要移动 3 次 + 绘制 1 次的话，就破坏了开闭原则。 123456789101112struct Game { vector&lt;Character *&gt; chars; void update() { for (auto &amp;&amp;c: chars) { c-&gt;move(); c-&gt;move(); c-&gt;move(); c-&gt;draw(); } }} 改为把移动 3 次 + 绘制 1 次封装为一个 Character 的普通函数 update。 1234567891011121314151617181920212223struct Character {protected: virtual void draw() = 0; virtual void move() = 0;public: void update() { move(); move(); move(); draw(); }};struct Game { vector&lt;Character *&gt; chars; void update() { for (auto &amp;&amp;c: chars) { c-&gt;update(); } }} 这样调用者就很轻松了，不必关心底层细节，而 update 也只通过接口和子类通信，满足开闭原则和依赖倒置原则。 模板模式还是策略模式：如何选择？当一个对象涉及很多策略时，用策略模式；当只需要一个策略，且需要用到基类的成员时，用模板模式。 例如，一个角色的策略有移动策略和攻击策略，移动方式有“走路”、“跑步”两种，攻击策略又有“平A”、“暴击”两种。 那么就用策略模式，让角色分别指向移动策略和攻击策略的指针。 123456789101112131415struct Character { MoveStrategy *moveStrategy; AttackStrategy *attackStrategy; void update() { if (isKeyPressed(GLFW_KEY_S) { moveStrategy-&gt;move(); } else if (isKeyPressed(GLFW_KEY_W)) { moveStrategy-&gt;run(); } while (auto enemy = Game::instance().findEnemy(range)) { attackStrategy-&gt;attack(enemy); } }}; 而如果只有一个策略，比如武器类，只需要攻击策略，并且攻击策略需要知道武器的伤害值、射程、附魔属性等信息，那就适合模板模式。 12345678910111213141516struct Weapon {protected: double damage; double charge; MagicFlag magicFlags; double range; virtual void attack(Enemy *enemy);public: void update() { while (auto enemy = Game::instance().findEnemy(range)) { attack(enemy); } }}; 最常见的是 do_xxx 封装例如，一个处理字符串的虚接口类： 123struct Converter { virtual void process(const char *s, size_t len) = 0;}; 这个接口是考虑 实现 Converter 子类的方便，对于 调用 Converter 的用户 使用起来可能并不方便。 这时候就可以运用模板模式，把原来的虚函数接口改为 protected 的函数，且名字改为 do_process。 1234567891011121314151617struct Converter {protected: virtual void do_process(const char *s, size_t len) = 0;public: void process(string_view str) { return do_process(str.data(), str.size()); } void process(string str) { return do_process(str.data(), str.size()); } void process(const char *cstr) { return do_process(cstr, strlen(cstr)); }}; 实现 Converter 的子类时，重写他的 do_process 函数，这些函数是 protected 的，只能被继承了 Converter 的子类访问和重写。 外层用户只能通过 Converter 基类封装好的 process 函数，避免外层用户直接干涉底层细节。 标准库中的 std::pmr::memory_resource、std::codecvt 等都运用了 do_xxx 式的模板模式封装。 状态模式游戏中的角色通常有多种状态，例如，一个怪物可能有“待机”、“巡逻”、“追击”、“攻击”等多种状态，而每种状态下的行为都不一样。 如果用一个枚举变量来表示当前状态，那每次就都需要用 switch 来处理不同的状态。 12345678910111213141516171819202122232425262728enum MonsterState { Idle, Chase, Attack,};struct Monster { MonsterState state = Idle; void update() { switch (state) { case Idle: if (seesPlayer()) state = Chase; break; case Chase: if (canAttack()) state = Attack; else if (!seesPlayer()) state = Idle; break; case Attack: if (!seesPlayer()) state = Idle; break; } }}; 这或许性能上有一定优势，缺点是，所有不同状态的处理逻辑堆积在同一个函数中，如果有多个函数（不只是 update），那么每添加一个新状态就需要修改所有函数，不符合开闭原则。 而且如果不同的状态含有不同的额外数值需要存储，比如 Chase 状态需要存储当前速度，那就需要在 Monster 类中添加 speed 成员，而 state 不为 Chase 时又用不到这个成员，非常容易扰乱思维。 状态不是枚举，而是类为此，提出了状态模式，将不同状态的处理逻辑分离到不同的类中。他把每种状态抽象为一个类，状态是一个对象，让角色持有表示当前状态的对象，用状态对象的虚函数来表示处理逻辑，而不必每次都通过 if 判断来执行不同的行为。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Monster;struct State { virtual void update(Monster *monster) = 0;};struct Idle : State { void update(Monster *monster) override { if (monster-&gt;seesPlayer()) { monster-&gt;setState(new Chase()); } }};struct Chase : State { void update(Monster *monster) override { if (monster-&gt;canAttack()) { monster-&gt;setState(new Attack()); } else if (!monster-&gt;seesPlayer()) { monster-&gt;setState(new Idle()); } }};struct Attack : State { void update(Monster *monster) override { if (!monster-&gt;seesPlayer()) { monster-&gt;setState(new Idle()); } }};struct Monster { State *state = new Idle(); void update() { state-&gt;update(this); } void setState(State *newState) { delete state; state = newState; }}; 原型模式原型模式用于复制现有的对象，且新对象的属性和类型与原来相同。如何实现？ 为什么拷贝构造函数不行？ 拷贝构造函数只能用于类型确定的情况，对于具有虚函数，可能具有额外成员的多态类型，会发生 object-slicing，导致拷贝出来的类型只是基类的部分，而不是完整的子类对象。 12RedBall ball;Ball newball = ball; // 错误：发生了 object-slicing！现在 newball 的类型只是 Ball 了，丢失了 RedBall 的信息 为什么拷贝指针不行？ 指针的拷贝是浅拷贝，而我们需要的是深拷贝。 12Ball *ball = new RedBall();Ball *newball = ball; // 错误：指针的拷贝是浅拷贝！newball 和 ball 指向的仍然是同一对象 需要调用到真正的构造函数，同时又基于指针 12Ball *ball = new RedBall();Ball *newball = new RedBall(*dynamic_cast&lt;RedBall *&gt;(ball)); // 可以，但是这里显式写出了 ball 内部的真正类型，违背了开闭原则 将拷贝构造函数封装为虚函数 原型模式将对象的拷贝方法作为虚函数，返回一个虚接口的指针，避免了直接拷贝类型。但虚函数内部会调用子类真正的构造函数，实现深拷贝。 对于熟悉工厂模式的同学：原型模式相当于把每个对象变成了自己的工厂，只需要有一个现有的对象，就能不断复制出和他相同类型的对象来。 1234567891011121314151617struct Ball { virtual Ball *clone() = 0;};struct RedBall : Ball { Ball *clone() override { return new RedBall(*this); // 调用 RedBall 的拷贝构造函数 }};struct BlueBall : Ball { Ball *clone() override { return new BlueBall(*this); // 调用 BlueBall 的拷贝构造函数 } int someData; // 如果有成员变量，也会一并被拷贝到}; 好处是，调用者无需知道具体类型，只需要他是 Ball 的子类，就可以克隆出一份完全一样的子类对象来，且返回的也是指针，不会发生 object-slicing。 123Ball *ball = new RedBall();...Ball *newball = ball-&gt;clone(); // newball 的类型仍然是 RedBall clone 返回为智能指针1234567891011121314151617struct Ball { virtual unique_ptr&lt;Ball&gt; clone() = 0;};struct RedBall : Ball { unique_ptr&lt;Ball&gt; clone() override { return make_unique&lt;RedBall&gt;(*this); // 调用 RedBall 的拷贝构造函数 }};struct BlueBall : Ball { unique_ptr&lt;Ball&gt; clone() override { return make_unique&lt;BlueBall&gt;(*this); // 调用 BlueBall 的拷贝构造函数 } int someData; // 如果有成员变量，也会一并被拷贝到新对象中}; 这样就保证了内存不会泄漏。 如果调用者需要的是 shared_ptr，怎么办？ 答：unique_ptr 可以隐式转换为 shared_ptr。 如果调用者需要的是手动 delete 的原始指针，怎么办？ 答：unique_ptr 可以通过 release，故意造成一次内存泄漏，成为需要手动管理的原始指针。 组件模式游戏中的物体（游戏对象）通常由多个组件组成，例如，一个角色可能由“角色控制器”、“角色外观”、“角色动画”等组件组成，一个子弹可能由“子弹物理”、“子弹外观”等组件组成。 组件模式是游戏开发领域最重要的设计模式，它将游戏对象分为多个组件，每个组件只关心自己的逻辑，而不关心其他组件的逻辑。 蹩脚的游戏开发者（通常是 985 量产出来的象牙塔巨婴）会把每个组件写成一个类，然后使用“多重继承”继承出一个玩家类来，并恬不知耻地声称“我也会组件模式了”。 然而，这样的缺点有： 游戏开发中普遍涉及到 update 函数，而玩家类的 update 需要轮流调用每个组件的 update 函数。 而多重继承一旦遇到重名的 update 函数，会直接报错 “有歧义的函数名” 摆烂不干了，需要你手写新的 update 函数。 1234567struct Player : PlayerController, PlayerAppearance, PlayerAnimation { void update() { PlayerController::update(); PlayerAppearance::update(); PlayerAnimation::update(); }}; C++（和大多数非脚本语言都）不支持运行时添加或删除基类，也就是说，如果要添加一个新角色，或是修改现有角色的逻辑，就需要重新编译一遍整个游戏的源码。 在网络游戏中，更新 DLL 和更新资产（图片、音频、模型等）是完全不同的。 对于服务端而言，更新 DLL 需要停机更新，更新资产不需要，DLL 可以被编程允许动态加载新的贴图。 对于客户端而言，更新 DLL 需要重新走一遍很长的 App 审核流程（因为直接运行于手机上的 C++ 可以轻松植入病毒），而更新资产的审核流程短得多，甚至干脆无需审核。 因此，游戏开发者很少会把游戏逻辑直接写死在 C++ 中，这会让更新游戏逻辑（例如修复 BUG）需要停机更新。（例如明日方舟每次停机更新都会给玩家发 200 合成玉） 你经常看到游戏领域的 “C++ 开发岗” 实际上是 “解释器开发”。 游戏开发者会把经常需要维护和更新的游戏逻辑写在如 Lua、Python 等脚本语言中，然后在 C++ 中集成一个 Lua、Python 解释器，根据解释器的调用结果，动态创建出 C++ 对象，然后把这些 C++ 对象当作组件添加到游戏对象上。 当出现 BUG 时，只需要修改这些脚本语言的代码，然后以“资产”的形式，快速走一遍审核流程，就可以修复 BUG，无需停机更新。（例如明日方舟有时候会“资源已过期”“正在下载资源”，有时是更新了图片资源，也可能是在脚本语言里动态修复了 BUG） Java 和 C# 都没有多重继承。你让人家基于 C# 的 Unity 怎么活？ 因此，真正的组件模式都会允许动态插入组件，而不是编译期写死。除非你是某些象牙塔的一次性沙雕大作业。 游戏对象组件化后，可以灵活地组合出不同的游戏对象，而不必为每一种组合都写一个类。 123456789101112131415161718struct Component { virtual void update(GameObject *go) = 0; virtual ~Component() = default; // 注意！};struct GameObject { vector&lt;Component *&gt; components; void add(Component *component) { components.push_back(component); } void update() { for (auto &amp;&amp;c: components) { c-&gt;update(this); } }}; 注意：Component 的析构函数必须为虚函数。否则，当 Component 被 delete 时，只会调用到 Component 这个基类的析构函数，而不会调用到子类的析构函数。 否则，如果你的子类有 string、vector 这种持有内存资源的容器类，会发生内存泄漏，导致游戏运行越久内存占用越大。 神奇的是，如果你的 Component 全部都是用 make_shared 创建的，那就没有内存泄漏了，这得益于 shared_ptr 会对 deleter 做类型擦除。make_unique 和 new 创建的就会泄漏，因为他们 delete 时是以基类指针去 delete 的，而 shared_ptr 会在构造时就记住子类的 deleter。 所有组件，都支持 update（每帧更新）操作： 12345678struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void update(GameObject *go) override { position += velocity * dt; }}; 12345678910struct LivingBeing : Component { int ageLeft; void update(GameObject *go) override { if (ageLeft &lt; 0) go-&gt;kill(); else ageLeft -= 1; }}; 组件的创建组件有两种创建方式： 组件作为一个普通对象，由 GameObject 的构造函数创建。 1234567891011121314151617struct Player : GameObject { Movable *movable; LivingBeing *livingBeing; PlayerController *playerController; PlayerAppearance *playerAppearance; Player() { movable = new Movable(); livingBeing = new LivingBeing(42); playerController = new PlayerController(); playerAppearance = new PlayerAppearance(); add(movable); add(livingBeing); add(playerController); add(playerAppearance); }}; 不再需要定义 Player 类及其构造函数了，只需一个普通函数创建具有 Player 所需所有组件的 GameObject 对象即可。 12345678910GameObject *makePlayer() { GameObject *go = new GameObject(); go-&gt;add(new Movable()); go-&gt;add(new LivingBeing(42)); go-&gt;add(new PlayerController()); go-&gt;add(new PlayerAppearance()); return go;} 正经游戏引擎都采用后者，不用添加 C++ 源码，只是从 xml 等配置文件读取每个类所依赖的组件，就能创建新的玩家类，方便动态更新游戏逻辑而无需重新发布 dll。 组件之间如何通信缺点是，组件之间的通信需要通过 GameObject 来实现，而 GameObject 并不知道它的组件是什么，这样就无法直接访问组件的成员。 例如，PlayerController 组件想要改变 Movable 组件的 velocity，就无法直接改。 12345678910111213141516struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { go-&gt;velocity.y += 1; // 错误！velocity 是 Movable 组件的成员，而不是 GameObject 里直接有的 } if (isKeyPressed(GLFW_KEY_S)) { go-&gt;velocity.y -= 1; } if (isKeyPressed(GLFW_KEY_A)) { go-&gt;velocity.x -= 1; } if (isKeyPressed(GLFW_KEY_D)) { go-&gt;velocity.x += 1; } }}; 如何解决组件之间通信难的问题？ 把常用的字段，例如 position 和 velocity 直接放在 GameObject 里，供所有组件直接访问。 123456struct GameObject { glm::vec3 position; glm::vec3 velocity; ...}; 允许用户根据其他组件的类型，直接获取出其他组件的指针，即可访问其成员。 1234567891011121314151617181920struct PlayerController : Component { void update(GameObject *go) override { Movable *movable = go-&gt;getComponent&lt;Movable&gt;(); if (!movable) { throw runtime_error(&quot;这个对象似乎不支持移动&quot;); } if (isKeyPressed(GLFW_KEY_W)) { movable-&gt;velocity.y += 1; } if (isKeyPressed(GLFW_KEY_S)) { movable-&gt;velocity.y -= 1; } if (isKeyPressed(GLFW_KEY_A)) { movable-&gt;velocity.x -= 1; } if (isKeyPressed(GLFW_KEY_D)) { movable-&gt;velocity.x += 1; } }}; 然而，getComponent 如何实现？ 1234567891011struct GameObject { template &lt;class T&gt; T *getComponent() { for (auto &amp;&amp;c: components) { if (T *t = dynamic_cast&lt;T *&gt;(c)) { return t; } } return nullptr; }}; 用到了 dynamic_cast，这是比较低效的一种实现方式，而且也不符合开闭原则。 更好的实现方式是利用 typeid 做 map 的键，加速查找。没有性能问题，但依然不符合开闭原则。 12345678910111213141516struct GameObject { unordered_map&lt;type_index, Component *&gt; components; template &lt;class T&gt; T *getComponent() { if (auto it = components.find(typeid(T)); it != components.end()) { return dynamic_cast&lt;T *&gt;(it-&gt;second); } else { return nullptr; } } void add(Component *component) { components[typeid(*component)] = component; }}; 让 PlayerController 发出指定类型的消息对象，由 Movable 检查并处理。 消息类型也是多态的，初学者可以先通过 dynamic_cast 实现类型检查。稍后我们会介绍更专业的访问者模式。 通常来说，我们只能把子类指针转换为基类指针。 而 dynamic_cast 可以把基类指针转换为子类指针。 如果他指向的对象确实就是那个子类类型的话，就正常返回子类指针了。 否则，如果类型不匹配，dynamic_cast 会返回 nullptr。只需判断返回的指针是不是 nullptr 就知道是否类型匹配了。 观察者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Message { virtual ~Message() = default; // C++ 规定：只有多态类型才能 dynamic_cast，这里我们用不到虚函数，那就只让析构函数为虚函数，即可使 Message 变为多态类型};struct MoveMessage : Message { glm::vec3 velocityChange;};struct Component { virtual void update(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default;};struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void handleMessage(Message *msg) override { // 所有不同的消息类型都会进入此函数 if (MoveMessage *mm = dynamic_cast&lt;MoveMessage *&gt;(msg)) { // 但只有真正类型为 MoveMessage 的消息会被处理 velocity += mm-&gt;velocityChange; } }};struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-&gt;send(&amp;mm); } }}; 12345678910111213141516171819struct GameObject { vector&lt;Component *&gt; components; void add(Component *component) { components.push_back(component); } void update() { for (auto &amp;&amp;c: components) { c-&gt;update(this); } } void send(Message *msg) { for (auto &amp;&amp;c: components) { c-&gt;handleMessage(msg); } }}; 这就是所谓的观察者模式，由于每个组件都可以收到所有消息，因此，可以实现组件之间的通信。 但这样做的缺点是，每个组件都需要处理所有消息，不论是否是自己需要的，如果组件数量多，消息类型又多，就会出现性能问题。 发布-订阅模式发布-订阅模式是观察者模式的升级版，由一个中心的事件总线来管理消息的分发。事件总线通常作为 GameObject 的成员出现。 每个组件可以订阅自己感兴趣的消息类型，当事件总线收到消息时，只把消息分发给订阅者，而不是所有组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct GameObject { vector&lt;Component *&gt; components; unordered_map&lt;type_index, vector&lt;Component *&gt;&gt; subscribers; // 事件总线 template &lt;class EventType&gt; void subscribe(Component *component) { subscribers[type_index(typeid(EventType))].push_back(component); } template &lt;class EventType&gt; void send(EventType *msg) { for (auto &amp;&amp;c: subscribers[type_index(typeid(EventType))]) { c-&gt;handleMessage(msg); } } void add(Component *component) { components.push_back(component); component-&gt;subscribeMessages(this); } void update() { for (auto &amp;&amp;c: components) { c-&gt;update(this); } }};struct Component { virtual void update(GameObject *go) = 0; virtual void subscribeMessages(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default;};struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void subscribeMessages(GameObject *go) { go-&gt;subscribe&lt;MoveMessage&gt;(this); } void handleMessage(Message *msg) override { if (MoveMessage *mm = dynamic_cast&lt;MoveMessage *&gt;(msg)) { velocity += mm-&gt;velocityChange; } }};struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-&gt;send(&amp;mm); } if (isKeyPressed(GLFW_KEY_SPACE)) { JumpMessage jm; go-&gt;send(&amp;jm); } }}; 这样，就可以实现组件之间的按需通信。","link":"/ChinYoBlog/2024/07/30/cppdesignmode/"},{"title":"如何优雅的使用Github Action服务来将Hexo部署到Github Pages","text":"参考文章Bilibili视频教程-9分钟零成本搭建自动化部署个人博客(Hexo + Github Action + Page)Hexo官方文档利用 GitHub Action 自动部署 Hexo 博客Hexo主题-Icarus快速上手 前提条件当前PC环境中有Node和Git。版本可以参考Hexo文档。 文章中出现的yourusername为Github用户名，your-repo为仓库名。 1. 初始化Hexo安装脚手架，初始化hexo，这会新建blog文件夹，进入后安装依赖。 1234npm install -g hexo-clihexo init blogcd blognpm install 2. 初始化仓库可以选择利用VSCode等软件直接对项目开源到github仓库。 也可以手动去github创建一个空仓库，然后手动在命令行中推送。 12345git initgit remote add origin https://github.com/yourusername/your-repo.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin main 3. 创建Token在个人设置中新增一个Personal access tokens。至少要包含repo权限，然后记住token。这个token是给Github Action用的，Github Action会把Hexo编译部署到gh-pages分支。 随后在存放Hexo代码的仓库里把这个Token新增进去，名称为GH_TOKEN(随意，后面需要一致)。 4. 修改_config.yml在_config.yml中修改deploy字段。指示Hexo在deploy时的推送地址。 1234deploy: type: git repo: https://github.com/yourusername/your-repo.git branch: gh-pages 5. 配置Github Action工作流在.github文件夹下新增workflows文件夹，然后新增deploy.yml文件，内容如下。 里面有个node-version要和你本地的node一致。步骤大致意思就是使用ubuntu-latest作为基础环境，然后安装各种依赖，随后hexo generate生成博客网站静态文件夹，把这个文件夹推送到同一仓库的gh-pages分支。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950name: Deploy Hexo to GitHub Pageson: push: branches: - main # 当推送到 main 分支时触发jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 with: submodules: false # 禁用子模块检查 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '18' - name: Install Dependencies run: npm install - name: Install Hexo Git Deployer run: | npm install hexo-deployer-git --save npm install hexo-cli -g - name: Clean and Generate Static Files run: | hexo clean hexo generate - name: Configure Git run: | git config --global user.name 'github-actions[bot]' git config --global user.email 'github-actions[bot]@users.noreply.github.com' - name: Deploy to GitHub Pages env: GH_TOKEN: ${{ secrets.GH_TOKEN }} run: | cd public/ git init git add -A git commit -m &quot;Create by workflows&quot; git remote add origin https://${{ secrets.GH_TOKEN }}@github.com/yourusername/your-repo.git git push origin HEAD:gh-pages -f 6. 推送验证把刚才更新的所有文件都推送一遍，github就会触发工作流，然后去网站看工作流运转的如何。等一切运转完毕，就会发现仓库多出一个gh-pages分支。 7. 配置Github Pages在仓库settings中配置page来源为gh-pages分支即可。等待网站部署完毕，就可以看了。网站链接可以在settings的GitHub Pages看到，也可以去action里看到。 8. 修改Hexo主题样式以一个比较热门的主题为演示示例，参考地址https://github.com/ppoffice/hexo-theme-icarus。 若要使用NPM将Icarus安装为Node包，在你的Hexo站点根目录运行如下命令： 1npm install -S hexo-theme-icarus hexo-renderer-inferno 接下来，使用hexo命令修改主题为Icarus: 1hexo config theme icarus 会发现多出一个_config.icarus.yml文件。这是Icarus主题的配置文件。 最后推送到仓库，等待部署后，就可以了。 10. 添加文章你可以执行下列命令来创建一篇新文章或者新的页面。 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 文章添加编辑后，现在只需要推送到仓库，那么github不仅会保存你的Hexo个人博客源码，还会自动更新个人博客静态页面到gh-pages，由此触发github-page功能来更新你的个人博客网站。 遇到了一些问题和方案1. 网站没有样式问题在网站打开F12，发现css等样式资源无法加载，仔细查看报错原因和请求地址，发现并不是当前仓库。 缺少仓库地址，所以把请求地址复制一份，并在后面添加上仓库名即可，这需要修改_config.yml中修改url字段。yourusername似乎为小写。 推送后等待工作流执行，查看结果。 12url: https://yourusername.github.io/your-reporoot: /your-repo/ 2. 图片不显示在_config.yml中设置 1post_asset_folder: true 意思是每个md博文会单独配套一个同名文件夹，用来存放图片。形如 1234source/_posts/├── my-new-post.md└── my-new-post/ └── example.jpg hexo提供三种语法 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 那么在md中可以这样引用图片 1{% asset_img example.jpg This is an example image %} 这样一来，部署的时候图片就不会不显示了，但是有个新的问题，我在本地编辑md的时候无法预览图片怎么办。 建议用VSCode下载插件vscode-hexo和Hexo Utils，随后在左边栏目就可以看到新Hexo Utils的新菜单，只要你的VSCode当前打开的文件夹是hexo的根目录，那么插件就会自动识别到，当你对md文件使用“侧边预览”时，图片就正常显示了。","link":"/ChinYoBlog/2024/03/19/record/"},{"title":"C++ 共享指针","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode* next) : val(x), next(next) {}};template &lt;class T&gt;struct SpControlBlock { T* m_data; int m_refcnt; explicit SpControlBlock(T* ptr) : m_data(ptr), m_refcnt(1) {} SpControlBlock(SpControlBlock&amp;&amp;) = delete; ~SpControlBlock() { delete m_data; }};template &lt;class T&gt;struct SharedPtr { SpControlBlock&lt;T&gt;* m_cb; explicit SharedPtr(T* ptr) : m_cb(new SpControlBlock&lt;T&gt;(ptr)) { } SharedPtr(const SharedPtr&amp; that) : m_cb(that.m_cb) { m_cb-&gt;m_refcnt++; } ~SharedPtr() { m_cb-&gt;m_refcnt--; if (m_cb-&gt;m_refcnt == 0) { delete m_cb; } } T* get() const { return m_cb-&gt;m_data; } SharedPtr&amp; operator=(const SharedPtr&amp; other) { if (this != &amp;other) { if (m_cb) { m_cb-&gt;m_refcnt--; if (m_cb-&gt;m_refcnt == 0) { delete m_cb; } } m_cb = other.m_cb; if (m_cb) { m_cb-&gt;m_refcnt++; } } return *this; } T* operator-&gt;() const { return m_cb-&gt;m_data; } T&amp; operator*() const { return *(m_cb-&gt;m_data); }};template&lt;class T, class ...Args&gt;SharedPtr&lt;T&gt; makeShared(Args &amp;&amp; ...args) { return SharedPtr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));}int main() { // TODO : SharedPtr&lt;ListNode&gt; a(new ListNode(6)); SharedPtr&lt;ListNode&gt; b(new ListNode(32)); SharedPtr&lt;ListNode&gt; c(new ListNode(38)); a = b = c; return 0;}","link":"/ChinYoBlog/2024/07/07/offer/"},{"title":"UE5反射","text":"参考链接：(我需要的内容转载) 【UE 反射】反射的原理是什么？如何使用机制？ 【UE·底层篇】一文搞懂StaticClass、GetClass和ClassDefaultObject 反射Unreal Engine（UE）实现反射机制是为了提供一种灵活且强大的方式来处理对象的属性和方法，尤其是在编辑器、脚本和序列化等场景中。以下是Unreal Engine中实现反射机制的主要原因和应用场景：\\ 编辑器支持 反射机制使得UE4编辑器能够动态地显示和修改对象的属性。这对于开发人员和设计师来说极其重要，因为它们可以在编辑器中直接调整游戏对象的属性，而无需重新编译代码。 属性面板: 通过反射，编辑器可以自动生成用户界面，让开发者和设计师在属性面板中查看和修改对象的属性。 蓝图编辑器: 蓝图是UE4中的可视化脚本语言，利用反射机制，蓝图编辑器可以动态地识别和调用C++类中的方法和属性。 序列化 反射机制使得对象的自动序列化和反序列化变得更加容易。UE4中使用反射来读取和写入对象的属性，以便保存和加载游戏状态、资源等。 保存和加载: 使用反射，可以自动将对象的属性保存到文件中，并在需要时重新加载。 网络同步: 在多人游戏中，反射机制可以用来同步游戏状态，使得对象的属性在网络上传输时能够自动序列化和反序列化。 动态对象创建 反射机制允许在运行时动态创建和管理对象。这在需要根据运行时条件动态加载和创建对象的场景中特别有用。 工厂模式: 反射可以用于实现工厂模式，动态创建对象实例，而无需在编译时确定具体的类。 模块和插件: 通过反射，可以动态加载和使用模块或插件中的类和对象，增强引擎的扩展性和灵活性。 脚本语言支持 UE4支持使用脚本语言（如Blueprint）来编写游戏逻辑。反射机制使得脚本语言能够访问和调用C++类中的属性和方法，从而实现脚本与引擎核心代码的无缝集成。 脚本调用C++方法: 通过反射，脚本语言可以调用C++类中的方法，访问对象的属性，实现高度的灵活性和动态性。 跨语言互操作: 反射机制使得不同语言之间能够方便地进行互操作，提高了引擎的扩展能力。 自动化测试和调试 反射机制在自动化测试和调试中也起到了重要作用。通过反射，可以动态地检查对象的状态，调用对象的方法，从而实现更加灵活和全面的测试。 自动化测试工具: 测试工具可以通过反射机制自动化地调用对象的方法，设置对象的状态，从而进行全面的测试覆盖。 调试工具: 调试工具可以利用反射机制动态检查对象的状态，帮助开发者快速定位和修复问题。 函数接口GetClass()GetClass() 的作用就是我们生成一个UObject实例后，去拿这个实例的UClass，如果是父类指针，拿到的是当前实际类型的Class GetStaticClass()不需要有UObject实例也能拿到某个类的UClass,初始化的默认值 ClassDefaultObject()蓝图修改后的UClass","link":"/ChinYoBlog/2024/06/23/uereflect/"}],"tags":[{"name":"C++","slug":"C","link":"/ChinYoBlog/tags/C/"},{"name":"UE5","slug":"UE5","link":"/ChinYoBlog/tags/UE5/"},{"name":"Hexo","slug":"Hexo","link":"/ChinYoBlog/tags/Hexo/"}],"categories":[{"name":"C++","slug":"C","link":"/ChinYoBlog/categories/C/"},{"name":"UE5","slug":"UE5","link":"/ChinYoBlog/categories/UE5/"},{"name":"Hexo","slug":"Hexo","link":"/ChinYoBlog/categories/Hexo/"}],"pages":[]}